{"ast":null,"code":"import _objectSpread from \"D:/MyFile/WebCode/ocean-vis/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport { defineComponent, ref, computed, nextTick, provide, reactive, watch, onBeforeUpdate, onMounted, resolveComponent, openBlock, createElementBlock, normalizeClass, Fragment, renderList, createBlock } from 'vue';\nimport { isEqual, flattenDeep } from 'lodash-unified';\nimport { isClient } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../constants/index.mjs';\nimport ElCascaderMenu from './menu.mjs';\nimport Store from './store.mjs';\nimport Node, { ExpandTrigger } from './node.mjs';\nimport { CommonProps, useCascaderConfig } from './config.mjs';\nimport { sortByOriginalOrder, checkNode, getMenuIndex } from './utils.mjs';\nimport { CASCADER_PANEL_INJECTION_KEY } from './types.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { UPDATE_MODEL_EVENT, CHANGE_EVENT } from '../../../constants/event.mjs';\nimport { isEmpty } from '../../../utils/types.mjs';\nimport { unique, castArray } from '../../../utils/arrays.mjs';\nimport { scrollIntoView } from '../../../utils/dom/scroll.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { focusNode, getSibling } from '../../../utils/dom/aria.mjs';\n\nvar _sfc_main = defineComponent({\n  name: \"ElCascaderPanel\",\n  components: {\n    ElCascaderMenu: ElCascaderMenu\n  },\n  props: _objectSpread(_objectSpread({}, CommonProps), {}, {\n    border: {\n      type: Boolean,\n      default: true\n    },\n    renderLabel: Function\n  }),\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, \"close\", \"expand-change\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit,\n        slots = _ref.slots;\n    var manualChecked = false;\n    var config = useCascaderConfig(props);\n    var store = null;\n    var initialLoaded = ref(true);\n    var menuList = ref([]);\n    var checkedValue = ref(null);\n    var menus = ref([]);\n    var expandingNode = ref(null);\n    var checkedNodes = ref([]);\n    var isHoverMenu = computed(function () {\n      return config.value.expandTrigger === ExpandTrigger.HOVER;\n    });\n    var renderLabelFn = computed(function () {\n      return props.renderLabel || slots.default;\n    });\n\n    var initStore = function initStore() {\n      var options = props.options;\n      var cfg = config.value;\n      manualChecked = false;\n      store = new Store(options, cfg);\n      menus.value = [store.getNodes()];\n\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded.value = false;\n        lazyLoad(void 0, function (list) {\n          if (list) {\n            store = new Store(list, cfg);\n            menus.value = [store.getNodes()];\n          }\n\n          initialLoaded.value = true;\n          syncCheckedValue(false, true);\n        });\n      } else {\n        syncCheckedValue(false, true);\n      }\n    };\n\n    var lazyLoad = function lazyLoad(node, cb) {\n      var cfg = config.value;\n      node = node || new Node({}, cfg, void 0, true);\n      node.loading = true;\n\n      var resolve = function resolve(dataList) {\n        var _node = node;\n        var parent = _node.root ? null : _node;\n        dataList && (store == null ? void 0 : store.appendNodes(dataList, parent));\n        _node.loading = false;\n        _node.loaded = true;\n        _node.childrenData = _node.childrenData || [];\n        cb && cb(dataList);\n      };\n\n      cfg.lazyLoad(node, resolve);\n    };\n\n    var expandNode = function expandNode(node, silent) {\n      var _a;\n\n      var level = node.level;\n      var newMenus = menus.value.slice(0, level);\n      var newExpandingNode;\n\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2];\n      } else {\n        newExpandingNode = node;\n        newMenus.push(node.children);\n      }\n\n      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {\n        expandingNode.value = node;\n        menus.value = newMenus;\n        !silent && emit(\"expand-change\", (node == null ? void 0 : node.pathValues) || []);\n      }\n    };\n\n    var handleCheckChange = function handleCheckChange(node, checked) {\n      var emitClose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var _config$value = config.value,\n          checkStrictly = _config$value.checkStrictly,\n          multiple = _config$value.multiple;\n      var oldNode = checkedNodes.value[0];\n      manualChecked = true;\n      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));\n      node.doCheck(checked);\n      calculateCheckedValue();\n      emitClose && !multiple && !checkStrictly && emit(\"close\");\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node);\n    };\n\n    var expandParentNode = function expandParentNode(node) {\n      if (!node) return;\n      node = node.parent;\n      expandParentNode(node);\n      node && expandNode(node);\n    };\n\n    var getFlattedNodes = function getFlattedNodes(leafOnly) {\n      return store == null ? void 0 : store.getFlattedNodes(leafOnly);\n    };\n\n    var getCheckedNodes = function getCheckedNodes(leafOnly) {\n      var _a;\n\n      return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter(function (node) {\n        return node.checked !== false;\n      });\n    };\n\n    var clearCheckedNodes = function clearCheckedNodes() {\n      checkedNodes.value.forEach(function (node) {\n        return node.doCheck(false);\n      });\n      calculateCheckedValue();\n    };\n\n    var calculateCheckedValue = function calculateCheckedValue() {\n      var _a;\n\n      var _config$value2 = config.value,\n          checkStrictly = _config$value2.checkStrictly,\n          multiple = _config$value2.multiple;\n      var oldNodes = checkedNodes.value;\n      var newNodes = getCheckedNodes(!checkStrictly);\n      var nodes = sortByOriginalOrder(oldNodes, newNodes);\n      var values = nodes.map(function (node) {\n        return node.valueByOption;\n      });\n      checkedNodes.value = nodes;\n      checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;\n    };\n\n    var syncCheckedValue = function syncCheckedValue() {\n      var loaded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var modelValue = props.modelValue;\n      var _config$value3 = config.value,\n          lazy = _config$value3.lazy,\n          multiple = _config$value3.multiple,\n          checkStrictly = _config$value3.checkStrictly;\n      var leafOnly = !checkStrictly;\n      if (!initialLoaded.value || manualChecked || !forced && isEqual(modelValue, checkedValue.value)) return;\n\n      if (lazy && !loaded) {\n        var values = unique(flattenDeep(castArray(modelValue)));\n        var nodes = values.map(function (val) {\n          return store == null ? void 0 : store.getNodeByValue(val);\n        }).filter(function (node) {\n          return !!node && !node.loaded && !node.loading;\n        });\n\n        if (nodes.length) {\n          nodes.forEach(function (node) {\n            lazyLoad(node, function () {\n              return syncCheckedValue(false, forced);\n            });\n          });\n        } else {\n          syncCheckedValue(true, forced);\n        }\n      } else {\n        var _values = multiple ? castArray(modelValue) : [modelValue];\n\n        var _nodes = unique(_values.map(function (val) {\n          return store == null ? void 0 : store.getNodeByValue(val, leafOnly);\n        }));\n\n        syncMenuState(_nodes, false);\n        checkedValue.value = modelValue;\n      }\n    };\n\n    var syncMenuState = function syncMenuState(newCheckedNodes) {\n      var reserveExpandingState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var checkStrictly = config.value.checkStrictly;\n      var oldNodes = checkedNodes.value;\n      var newNodes = newCheckedNodes.filter(function (node) {\n        return !!node && (checkStrictly || node.isLeaf);\n      });\n      var oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);\n      var newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];\n\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach(function (node) {\n          return expandNode(node, true);\n        });\n      } else {\n        expandingNode.value = null;\n      }\n\n      oldNodes.forEach(function (node) {\n        return node.doCheck(false);\n      });\n      newNodes.forEach(function (node) {\n        return node.doCheck(true);\n      });\n      checkedNodes.value = newNodes;\n      nextTick(scrollToExpandingNode);\n    };\n\n    var scrollToExpandingNode = function scrollToExpandingNode() {\n      if (!isClient) return;\n      menuList.value.forEach(function (menu) {\n        var menuElement = menu == null ? void 0 : menu.$el;\n\n        if (menuElement) {\n          var container = menuElement.querySelector(\".el-scrollbar__wrap\");\n          var activeNode = menuElement.querySelector(\".el-cascader-node.is-active\") || menuElement.querySelector(\".el-cascader-node.in-active-path\");\n          scrollIntoView(container, activeNode);\n        }\n      });\n    };\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var target = e.target;\n      var code = e.code;\n\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down:\n          {\n            e.preventDefault();\n            var distance = code === EVENT_CODE.up ? -1 : 1;\n            focusNode(getSibling(target, distance, '.el-cascader-node[tabindex=\"-1\"]'));\n            break;\n          }\n\n        case EVENT_CODE.left:\n          {\n            e.preventDefault();\n            var preMenu = menuList.value[getMenuIndex(target) - 1];\n            var expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector('.el-cascader-node[aria-expanded=\"true\"]');\n            focusNode(expandedNode);\n            break;\n          }\n\n        case EVENT_CODE.right:\n          {\n            e.preventDefault();\n            var nextMenu = menuList.value[getMenuIndex(target) + 1];\n            var firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector('.el-cascader-node[tabindex=\"-1\"]');\n            focusNode(firstNode);\n            break;\n          }\n\n        case EVENT_CODE.enter:\n          checkNode(target);\n          break;\n\n        case EVENT_CODE.esc:\n        case EVENT_CODE.tab:\n          emit(\"close\");\n          break;\n      }\n    };\n\n    provide(CASCADER_PANEL_INJECTION_KEY, reactive({\n      config: config,\n      expandingNode: expandingNode,\n      checkedNodes: checkedNodes,\n      isHoverMenu: isHoverMenu,\n      initialLoaded: initialLoaded,\n      renderLabelFn: renderLabelFn,\n      lazyLoad: lazyLoad,\n      expandNode: expandNode,\n      handleCheckChange: handleCheckChange\n    }));\n    watch([config, function () {\n      return props.options;\n    }], initStore, {\n      deep: true,\n      immediate: true\n    });\n    watch(function () {\n      return props.modelValue;\n    }, function () {\n      manualChecked = false;\n      syncCheckedValue();\n    });\n    watch(checkedValue, function (val) {\n      if (!isEqual(val, props.modelValue)) {\n        emit(UPDATE_MODEL_EVENT, val);\n        emit(CHANGE_EVENT, val);\n      }\n    });\n    onBeforeUpdate(function () {\n      return menuList.value = [];\n    });\n    onMounted(function () {\n      return !isEmpty(props.modelValue) && syncCheckedValue();\n    });\n    return {\n      menuList: menuList,\n      menus: menus,\n      checkedNodes: checkedNodes,\n      handleKeyDown: handleKeyDown,\n      handleCheckChange: handleCheckChange,\n      getFlattedNodes: getFlattedNodes,\n      getCheckedNodes: getCheckedNodes,\n      clearCheckedNodes: clearCheckedNodes,\n      calculateCheckedValue: calculateCheckedValue,\n      scrollToExpandingNode: scrollToExpandingNode\n    };\n  }\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_el_cascader_menu = resolveComponent(\"el-cascader-menu\");\n\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass([\"el-cascader-panel\", _ctx.border && \"is-bordered\"]),\n    onKeydown: _cache[0] || (_cache[0] = function () {\n      return _ctx.handleKeyDown && _ctx.handleKeyDown.apply(_ctx, arguments);\n    })\n  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menus, function (menu, index) {\n    return openBlock(), createBlock(_component_el_cascader_menu, {\n      key: index,\n      ref_for: true,\n      ref: function ref(item) {\n        return _ctx.menuList[index] = item;\n      },\n      index: index,\n      nodes: menu\n    }, null, 8, [\"index\", \"nodes\"]);\n  }), 128))], 34);\n}\n\nvar CascaderPanel = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { CascaderPanel as default };","map":{"version":3,"mappings":"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","names":["_sfc_main","defineComponent","name","components","ElCascaderMenu","props","CommonProps","border","type","Boolean","default","renderLabel","Function","emits","UPDATE_MODEL_EVENT","CHANGE_EVENT","setup","emit","slots","manualChecked","config","useCascaderConfig","store","initialLoaded","ref","menuList","checkedValue","menus","expandingNode","checkedNodes","isHoverMenu","computed","value","expandTrigger","ExpandTrigger","HOVER","renderLabelFn","initStore","options","cfg","Store","getNodes","lazy","isEmpty","lazyLoad","list","syncCheckedValue","node","cb","Node","loading","resolve","dataList","_node","parent","root","loaded","childrenData","expandNode","silent","level","newExpandingNode","newMenus","_a","checkStrictly","multiple","calculateCheckedValue","emitClose","expandParentNode","leafOnly","oldNodes","forced","isEqual","filter","nodes","syncMenuState","modelValue","forEach","newNodes","nextTick","scrollIntoView","e","focusNode","EVENT_CODE","enter","checkNode","provide","handleCheckChange","watch","deep","immediate","val","onBeforeUpdate","onMounted","handleKeyDown","getFlattedNodes","getCheckedNodes","clearCheckedNodes","scrollToExpandingNode","$data","$options","openBlock","_openBlock","key","ref_for"],"sources":["../../../../../../packages/components/cascader-panel/src/index.vue"],"sourcesContent":["<template>\n  <div\n    :class=\"['el-cascader-panel', border && 'is-bordered']\"\n    @keydown=\"handleKeyDown\"\n  >\n    <el-cascader-menu\n      v-for=\"(menu, index) in menus\"\n      :key=\"index\"\n      :ref=\"(item) => (menuList[index] = item)\"\n      :index=\"index\"\n      :nodes=\"menu\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUpdate,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  watch,\n} from 'vue'\nimport { isEqual, flattenDeep } from 'lodash-unified'\nimport { isClient } from '@vueuse/core'\nimport {\n  focusNode,\n  getSibling,\n  isEmpty,\n  unique,\n  castArray,\n  scrollIntoView,\n} from '@element-plus/utils'\nimport {\n  EVENT_CODE,\n  UPDATE_MODEL_EVENT,\n  CHANGE_EVENT,\n} from '@element-plus/constants'\n\nimport ElCascaderMenu from './menu.vue'\nimport Store from './store'\nimport Node, { ExpandTrigger } from './node'\nimport { CommonProps, useCascaderConfig } from './config'\nimport { checkNode, getMenuIndex, sortByOriginalOrder } from './utils'\nimport { CASCADER_PANEL_INJECTION_KEY } from './types'\n\nimport type { PropType } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  CascaderValue,\n  CascaderNodeValue,\n  CascaderOption,\n  RenderLabel,\n  default as CascaderNode,\n} from './node'\n\nimport type { ElCascaderPanelContext } from './types'\n\nexport default defineComponent({\n  name: 'ElCascaderPanel',\n\n  components: {\n    ElCascaderMenu,\n  },\n\n  props: {\n    ...CommonProps,\n    border: {\n      type: Boolean,\n      default: true,\n    },\n    renderLabel: Function as PropType<RenderLabel>,\n  },\n\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'close', 'expand-change'],\n\n  setup(props, { emit, slots }) {\n    // for interrupt sync check status in lazy mode\n    let manualChecked = false\n\n    const config = useCascaderConfig(props)\n\n    let store: Nullable<Store> = null\n    const initialLoaded = ref(true)\n    const menuList = ref<any[]>([])\n    const checkedValue = ref<Nullable<CascaderValue>>(null)\n    const menus = ref<CascaderNode[][]>([])\n    const expandingNode = ref<Nullable<CascaderNode>>(null)\n    const checkedNodes = ref<CascaderNode[]>([])\n\n    const isHoverMenu = computed(\n      () => config.value.expandTrigger === ExpandTrigger.HOVER\n    )\n    const renderLabelFn = computed(() => props.renderLabel || slots.default)\n\n    const initStore = () => {\n      const { options } = props\n      const cfg = config.value\n\n      manualChecked = false\n      store = new Store(options, cfg)\n      menus.value = [store.getNodes()]\n\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded.value = false\n        lazyLoad(undefined, (list) => {\n          if (list) {\n            store = new Store(list, cfg)\n            menus.value = [store.getNodes()]\n          }\n          initialLoaded.value = true\n          syncCheckedValue(false, true)\n        })\n      } else {\n        syncCheckedValue(false, true)\n      }\n    }\n\n    const lazyLoad: ElCascaderPanelContext['lazyLoad'] = (node, cb) => {\n      const cfg = config.value\n      node! = node || new Node({}, cfg, undefined, true)\n      node.loading = true\n\n      const resolve = (dataList: CascaderOption[]) => {\n        const _node = node as Node\n        const parent = _node.root ? null : _node\n        dataList && store?.appendNodes(dataList, parent as any)\n        _node.loading = false\n        _node.loaded = true\n        _node.childrenData = _node.childrenData || []\n        cb && cb(dataList)\n      }\n\n      cfg.lazyLoad(node, resolve as any)\n    }\n\n    const expandNode: ElCascaderPanelContext['expandNode'] = (node, silent) => {\n      const { level } = node\n      const newMenus = menus.value.slice(0, level)\n      let newExpandingNode: Nullable<CascaderNode>\n\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2]\n      } else {\n        newExpandingNode = node\n        newMenus.push(node.children)\n      }\n\n      if (expandingNode.value?.uid !== newExpandingNode?.uid) {\n        expandingNode.value = node\n        menus.value = newMenus\n        !silent && emit('expand-change', node?.pathValues || [])\n      }\n    }\n\n    const handleCheckChange: ElCascaderPanelContext['handleCheckChange'] = (\n      node,\n      checked,\n      emitClose = true\n    ) => {\n      const { checkStrictly, multiple } = config.value\n      const oldNode = checkedNodes.value[0]\n      manualChecked = true\n\n      !multiple && oldNode?.doCheck(false)\n      node.doCheck(checked)\n      calculateCheckedValue()\n      emitClose && !multiple && !checkStrictly && emit('close')\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node)\n    }\n\n    const expandParentNode = (node) => {\n      if (!node) return\n      node = node.parent\n      expandParentNode(node)\n      node && expandNode(node)\n    }\n\n    const getFlattedNodes = (leafOnly: boolean) => {\n      return store?.getFlattedNodes(leafOnly)\n    }\n\n    const getCheckedNodes = (leafOnly: boolean) => {\n      return getFlattedNodes(leafOnly)?.filter((node) => node.checked !== false)\n    }\n\n    const clearCheckedNodes = () => {\n      checkedNodes.value.forEach((node) => node.doCheck(false))\n      calculateCheckedValue()\n    }\n\n    const calculateCheckedValue = () => {\n      const { checkStrictly, multiple } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = getCheckedNodes(!checkStrictly)!\n      // ensure the original order\n      const nodes = sortByOriginalOrder(oldNodes, newNodes)\n      const values = nodes.map((node) => node.valueByOption)\n      checkedNodes.value = nodes\n      checkedValue.value = multiple ? values : values[0] ?? null\n    }\n\n    const syncCheckedValue = (loaded = false, forced = false) => {\n      const { modelValue } = props\n      const { lazy, multiple, checkStrictly } = config.value\n      const leafOnly = !checkStrictly\n\n      if (\n        !initialLoaded.value ||\n        manualChecked ||\n        (!forced && isEqual(modelValue, checkedValue.value))\n      )\n        return\n\n      if (lazy && !loaded) {\n        const values: CascaderNodeValue[] = unique(\n          flattenDeep(castArray(modelValue))\n        )\n        const nodes = values\n          .map((val) => store?.getNodeByValue(val))\n          .filter((node) => !!node && !node.loaded && !node.loading) as Node[]\n\n        if (nodes.length) {\n          nodes.forEach((node) => {\n            lazyLoad(node, () => syncCheckedValue(false, forced))\n          })\n        } else {\n          syncCheckedValue(true, forced)\n        }\n      } else {\n        const values = multiple ? castArray(modelValue) : [modelValue]\n        const nodes = unique(\n          values.map((val) => store?.getNodeByValue(val, leafOnly))\n        ) as Node[]\n        syncMenuState(nodes, false)\n        checkedValue.value = modelValue!\n      }\n    }\n\n    const syncMenuState = (\n      newCheckedNodes: CascaderNode[],\n      reserveExpandingState = true\n    ) => {\n      const { checkStrictly } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = newCheckedNodes.filter(\n        (node) => !!node && (checkStrictly || node.isLeaf)\n      )\n      const oldExpandingNode = store?.getSameNode(expandingNode.value!)\n      const newExpandingNode =\n        (reserveExpandingState && oldExpandingNode) || newNodes[0]\n\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true))\n      } else {\n        expandingNode.value = null\n      }\n\n      oldNodes.forEach((node) => node.doCheck(false))\n      newNodes.forEach((node) => node.doCheck(true))\n\n      checkedNodes.value = newNodes\n      nextTick(scrollToExpandingNode)\n    }\n\n    const scrollToExpandingNode = () => {\n      if (!isClient) return\n\n      menuList.value.forEach((menu) => {\n        const menuElement = menu?.$el\n        if (menuElement) {\n          const container = (menuElement as HTMLElement).querySelector(\n            '.el-scrollbar__wrap'\n          )\n          const activeNode =\n            menuElement.querySelector('.el-cascader-node.is-active') ||\n            menuElement.querySelector('.el-cascader-node.in-active-path')\n          scrollIntoView(container as HTMLElement, activeNode)\n        }\n      })\n    }\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const target = e.target as HTMLElement\n      const { code } = e\n\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down: {\n          e.preventDefault()\n          const distance = code === EVENT_CODE.up ? -1 : 1\n          focusNode(\n            getSibling(target, distance, '.el-cascader-node[tabindex=\"-1\"]')\n          )\n          break\n        }\n        case EVENT_CODE.left: {\n          e.preventDefault()\n          const preMenu = menuList.value[getMenuIndex(target) - 1]\n          const expandedNode = preMenu?.$el.querySelector(\n            '.el-cascader-node[aria-expanded=\"true\"]'\n          )\n          focusNode(expandedNode)\n          break\n        }\n        case EVENT_CODE.right: {\n          e.preventDefault()\n          const nextMenu = menuList.value[getMenuIndex(target) + 1]\n          const firstNode = nextMenu?.$el.querySelector(\n            '.el-cascader-node[tabindex=\"-1\"]'\n          )\n          focusNode(firstNode)\n          break\n        }\n        case EVENT_CODE.enter:\n          checkNode(target)\n          break\n        case EVENT_CODE.esc:\n        case EVENT_CODE.tab:\n          emit('close')\n          break\n      }\n    }\n\n    provide(\n      CASCADER_PANEL_INJECTION_KEY,\n      reactive({\n        config,\n        expandingNode,\n        checkedNodes,\n        isHoverMenu,\n        initialLoaded,\n        renderLabelFn,\n        lazyLoad,\n        expandNode,\n        handleCheckChange,\n      })\n    )\n\n    watch([config, () => props.options], initStore, {\n      deep: true,\n      immediate: true,\n    })\n\n    watch(\n      () => props.modelValue,\n      () => {\n        manualChecked = false\n        syncCheckedValue()\n      }\n    )\n\n    watch(checkedValue, (val) => {\n      if (!isEqual(val, props.modelValue)) {\n        emit(UPDATE_MODEL_EVENT, val)\n        emit(CHANGE_EVENT, val)\n      }\n    })\n\n    onBeforeUpdate(() => (menuList.value = []))\n\n    onMounted(() => !isEmpty(props.modelValue) && syncCheckedValue())\n\n    return {\n      menuList,\n      menus,\n      checkedNodes,\n      handleKeyDown,\n      handleCheckChange,\n      getFlattedNodes,\n      getCheckedNodes,\n      clearCheckedNodes,\n      calculateCheckedValue,\n      scrollToExpandingNode,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}