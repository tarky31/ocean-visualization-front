{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport { defineComponent, getCurrentInstance, shallowRef, ref, watch, onMounted, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle } from 'vue';\nimport '../../../../utils/index.mjs';\nimport draggable from '../draggable.mjs';\nimport _export_sfc from '../../../../_virtual/plugin-vue_export-helper.mjs';\nimport { getClientXY } from '../../../../utils/dom/position.mjs';\n\nvar _sfc_main = defineComponent({\n  name: \"ElColorAlphaSlider\",\n  props: {\n    color: {\n      type: Object,\n      required: true\n    },\n    vertical: {\n      type: Boolean,\n      default: false\n    }\n  },\n  setup: function setup(props) {\n    var instance = getCurrentInstance();\n    var thumb = shallowRef(null);\n    var bar = shallowRef(null);\n    var thumbLeft = ref(0);\n    var thumbTop = ref(0);\n    var background = ref(null);\n    watch(function () {\n      return props.color.get(\"alpha\");\n    }, function () {\n      update();\n    });\n    watch(function () {\n      return props.color.value;\n    }, function () {\n      update();\n    });\n\n    function getThumbLeft() {\n      if (props.vertical) return 0;\n      var el = instance.vnode.el;\n      var alpha = props.color.get(\"alpha\");\n      if (!el) return 0;\n      return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);\n    }\n\n    function getThumbTop() {\n      var el = instance.vnode.el;\n      if (!props.vertical) return 0;\n      var alpha = props.color.get(\"alpha\");\n      if (!el) return 0;\n      return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);\n    }\n\n    function getBackground() {\n      if (props.color && props.color.value) {\n        var _props$color$toRgb = props.color.toRgb(),\n            r = _props$color$toRgb.r,\n            g = _props$color$toRgb.g,\n            b = _props$color$toRgb.b;\n\n        return \"linear-gradient(to right, rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", 0) 0%, rgba(\").concat(r, \", \").concat(g, \", \").concat(b, \", 1) 100%)\");\n      }\n\n      return null;\n    }\n\n    function handleClick(event) {\n      var target = event.target;\n\n      if (target !== thumb.value) {\n        handleDrag(event);\n      }\n    }\n\n    function handleDrag(event) {\n      var el = instance.vnode.el;\n      var rect = el.getBoundingClientRect();\n\n      var _getClientXY = getClientXY(event),\n          clientX = _getClientXY.clientX,\n          clientY = _getClientXY.clientY;\n\n      if (!props.vertical) {\n        var left = clientX - rect.left;\n        left = Math.max(thumb.value.offsetWidth / 2, left);\n        left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);\n        props.color.set(\"alpha\", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));\n      } else {\n        var top = clientY - rect.top;\n        top = Math.max(thumb.value.offsetHeight / 2, top);\n        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);\n        props.color.set(\"alpha\", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));\n      }\n    }\n\n    function update() {\n      thumbLeft.value = getThumbLeft();\n      thumbTop.value = getThumbTop();\n      background.value = getBackground();\n    }\n\n    onMounted(function () {\n      var dragConfig = {\n        drag: function drag(event) {\n          handleDrag(event);\n        },\n        end: function end(event) {\n          handleDrag(event);\n        }\n      };\n      draggable(bar.value, dragConfig);\n      draggable(thumb.value, dragConfig);\n      update();\n    });\n    return {\n      thumb: thumb,\n      bar: bar,\n      thumbLeft: thumbLeft,\n      thumbTop: thumbTop,\n      background: background,\n      handleClick: handleClick,\n      update: update\n    };\n  }\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass([\"el-color-alpha-slider\", {\n      \"is-vertical\": _ctx.vertical\n    }])\n  }, [createElementVNode(\"div\", {\n    ref: \"bar\",\n    class: \"el-color-alpha-slider__bar\",\n    style: normalizeStyle({\n      background: _ctx.background\n    }),\n    onClick: _cache[0] || (_cache[0] = function () {\n      return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);\n    })\n  }, null, 4), createElementVNode(\"div\", {\n    ref: \"thumb\",\n    class: \"el-color-alpha-slider__thumb\",\n    style: normalizeStyle({\n      left: _ctx.thumbLeft + \"px\",\n      top: _ctx.thumbTop + \"px\"\n    })\n  }, null, 4)], 2);\n}\n\nvar AlphaSlider = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { AlphaSlider as default };","map":{"version":3,"mappings":"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","names":["_sfc_main","defineComponent","name","props","color","type","Object","required","vertical","Boolean","default","setup","instance","getCurrentInstance","thumb","shallowRef","bar","thumbLeft","ref","thumbTop","background","watch","get","update","value","el","vnode","alpha","Math","round","offsetWidth","offsetHeight","toRgb","r","g","b","event","target","handleDrag","rect","getBoundingClientRect","getClientXY","clientX","clientY","left","max","min","width","set","top","height","getThumbLeft","getThumbTop","getBackground","onMounted","dragConfig","drag","end","draggable","handleClick","_createElementBlock","class","_normalizeClass","_ctx","_createElementVNode","style","_normalizeStyle","onClick","_cache"],"sources":["../../../../../../../packages/components/color-picker/src/components/alpha-slider.vue"],"sourcesContent":["<template>\n  <div class=\"el-color-alpha-slider\" :class=\"{ 'is-vertical': vertical }\">\n    <div\n      ref=\"bar\"\n      class=\"el-color-alpha-slider__bar\"\n      :style=\"{\n        background,\n      }\"\n      @click=\"handleClick\"\n    ></div>\n    <div\n      ref=\"thumb\"\n      class=\"el-color-alpha-slider__thumb\"\n      :style=\"{\n        left: thumbLeft + 'px',\n        top: thumbTop + 'px',\n      }\"\n    ></div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  watch,\n  ref,\n  onMounted,\n  getCurrentInstance,\n  shallowRef,\n} from 'vue'\nimport { getClientXY } from '@element-plus/utils'\nimport draggable from '../draggable'\n\nimport type { PropType } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\nimport type Color from '../color'\n\nexport default defineComponent({\n  name: 'ElColorAlphaSlider',\n  props: {\n    color: {\n      type: Object as PropType<Color>,\n      required: true,\n    },\n    vertical: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props) {\n    const instance = getCurrentInstance()\n    // ref\n    const thumb = shallowRef<Nullable<HTMLElement>>(null)\n    const bar = shallowRef<Nullable<HTMLElement>>(null)\n\n    // data\n    const thumbLeft = ref(0)\n    const thumbTop = ref(0)\n    const background = ref<Nullable<string>>(null)\n\n    watch(\n      () => props.color.get('alpha'),\n      () => {\n        update()\n      }\n    )\n    watch(\n      () => props.color.value,\n      () => {\n        update()\n      }\n    )\n\n    //methods\n    function getThumbLeft() {\n      if (props.vertical) return 0\n      const el = instance.vnode.el\n      const alpha = props.color.get('alpha')\n\n      if (!el) return 0\n      return Math.round(\n        (alpha * (el.offsetWidth - thumb.value.offsetWidth / 2)) / 100\n      )\n    }\n\n    function getThumbTop() {\n      const el = instance.vnode.el\n      if (!props.vertical) return 0\n      const alpha = props.color.get('alpha')\n\n      if (!el) return 0\n      return Math.round(\n        (alpha * (el.offsetHeight - thumb.value.offsetHeight / 2)) / 100\n      )\n    }\n\n    function getBackground() {\n      if (props.color && props.color.value) {\n        const { r, g, b } = props.color.toRgb()\n        return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`\n      }\n      return null\n    }\n\n    function handleClick(event: Event) {\n      const target = event.target\n\n      if (target !== thumb.value) {\n        handleDrag(event)\n      }\n    }\n\n    function handleDrag(event) {\n      const el = instance.vnode.el as HTMLElement\n      const rect = el.getBoundingClientRect()\n      const { clientX, clientY } = getClientXY(event)\n\n      if (!props.vertical) {\n        let left = clientX - rect.left\n        left = Math.max(thumb.value.offsetWidth / 2, left)\n        left = Math.min(left, rect.width - thumb.value.offsetWidth / 2)\n\n        props.color.set(\n          'alpha',\n          Math.round(\n            ((left - thumb.value.offsetWidth / 2) /\n              (rect.width - thumb.value.offsetWidth)) *\n              100\n          )\n        )\n      } else {\n        let top = clientY - rect.top\n        top = Math.max(thumb.value.offsetHeight / 2, top)\n        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2)\n\n        props.color.set(\n          'alpha',\n          Math.round(\n            ((top - thumb.value.offsetHeight / 2) /\n              (rect.height - thumb.value.offsetHeight)) *\n              100\n          )\n        )\n      }\n    }\n\n    function update() {\n      thumbLeft.value = getThumbLeft()\n      thumbTop.value = getThumbTop()\n      background.value = getBackground()\n    }\n\n    // mounded\n    onMounted(() => {\n      const dragConfig = {\n        drag: (event) => {\n          handleDrag(event)\n        },\n        end: (event) => {\n          handleDrag(event)\n        },\n      }\n\n      draggable(bar.value, dragConfig)\n      draggable(thumb.value, dragConfig)\n      update()\n    })\n\n    return {\n      thumb,\n      bar,\n      thumbLeft,\n      thumbTop,\n      background,\n      handleClick,\n      update,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}