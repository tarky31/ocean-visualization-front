{"ast":null,"code":"import _toConsumableArray from \"D:/MyFile/WebCode/ocean-vis/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"D:/MyFile/WebCode/ocean-vis/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport { defineComponent, inject, ref, getCurrentInstance, computed, watch, nextTick, reactive, toRefs, onMounted, onBeforeUnmount, provide, resolveComponent, openBlock, createElementBlock, normalizeClass, createVNode, withCtx, normalizeStyle, renderSlot, createTextVNode, toDisplayString, createCommentVNode, createElementVNode, Transition } from 'vue';\nimport { NOOP } from '@vue/shared';\nimport AsyncValidator from 'async-validator';\nimport '../../../utils/index.mjs';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport LabelWrap from './label-wrap.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { isValidComponentSize } from '../../../utils/vue/validator.mjs';\nimport { elFormKey, elFormItemKey } from '../../../tokens/form.mjs';\nimport { addUnit } from '../../../utils/vue/style.mjs';\nimport { getPropByPath } from '../../../utils/objects.mjs';\nimport { useSize } from '../../../hooks/use-common-props/index.mjs';\n\nvar _sfc_main = defineComponent({\n  name: \"ElFormItem\",\n  componentName: \"ElFormItem\",\n  components: {\n    LabelWrap: LabelWrap\n  },\n  props: {\n    label: String,\n    labelWidth: {\n      type: [String, Number],\n      default: \"\"\n    },\n    prop: String,\n    required: {\n      type: Boolean,\n      default: void 0\n    },\n    rules: [Object, Array],\n    error: String,\n    validateStatus: String,\n    for: String,\n    inlineMessage: {\n      type: [String, Boolean],\n      default: \"\"\n    },\n    showMessage: {\n      type: Boolean,\n      default: true\n    },\n    size: {\n      type: String,\n      validator: isValidComponentSize\n    }\n  },\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots;\n    var elForm = inject(elFormKey, {});\n    var validateState = ref(\"\");\n    var validateMessage = ref(\"\");\n    var isValidationEnabled = ref(false);\n    var computedLabelWidth = ref(\"\");\n    var formItemRef = ref();\n    var vm = getCurrentInstance();\n    var isNested = computed(function () {\n      var parent = vm.parent;\n\n      while (parent && parent.type.name !== \"ElForm\") {\n        if (parent.type.name === \"ElFormItem\") {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    });\n    var initialValue = void 0;\n    watch(function () {\n      return props.error;\n    }, function (val) {\n      validateMessage.value = val;\n      validateState.value = val ? \"error\" : \"\";\n    }, {\n      immediate: true\n    });\n    watch(function () {\n      return props.validateStatus;\n    }, function (val) {\n      validateState.value = val;\n    });\n    var labelFor = computed(function () {\n      return props.for || props.prop;\n    });\n    var labelStyle = computed(function () {\n      var ret = {};\n      if (elForm.labelPosition === \"top\") return ret;\n      var labelWidth = addUnit(props.labelWidth || elForm.labelWidth);\n\n      if (labelWidth) {\n        ret.width = labelWidth;\n      }\n\n      return ret;\n    });\n    var contentStyle = computed(function () {\n      var ret = {};\n\n      if (elForm.labelPosition === \"top\" || elForm.inline) {\n        return ret;\n      }\n\n      if (!props.label && !props.labelWidth && isNested.value) {\n        return ret;\n      }\n\n      var labelWidth = addUnit(props.labelWidth || elForm.labelWidth);\n\n      if (!props.label && !slots.label) {\n        ret.marginLeft = labelWidth;\n      }\n\n      return ret;\n    });\n    var fieldValue = computed(function () {\n      var model = elForm.model;\n\n      if (!model || !props.prop) {\n        return;\n      }\n\n      var path = props.prop;\n\n      if (path.indexOf(\":\") !== -1) {\n        path = path.replace(/:/, \".\");\n      }\n\n      return getPropByPath(model, path, true).v;\n    });\n    var isRequired = computed(function () {\n      var rules = getRules();\n      var required = false;\n\n      if (rules && rules.length) {\n        rules.every(function (rule) {\n          if (rule.required) {\n            required = true;\n            return false;\n          }\n\n          return true;\n        });\n      }\n\n      return required;\n    });\n    var sizeClass = useSize(void 0, {\n      formItem: false\n    });\n\n    var validate = function validate(trigger) {\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NOOP;\n\n      if (!isValidationEnabled.value) {\n        callback();\n        return;\n      }\n\n      var rules = getFilteredRule(trigger);\n\n      if ((!rules || rules.length === 0) && props.required === void 0) {\n        callback();\n        return;\n      }\n\n      validateState.value = \"validating\";\n      var descriptor = {};\n\n      if (rules && rules.length > 0) {\n        rules.forEach(function (rule) {\n          delete rule.trigger;\n        });\n      }\n\n      descriptor[props.prop] = rules;\n      var validator = new AsyncValidator(descriptor);\n      var model = {};\n      model[props.prop] = fieldValue.value;\n      validator.validate(model, {\n        firstFields: true\n      }, function (errors, fields) {\n        var _a;\n\n        validateState.value = !errors ? \"success\" : \"error\";\n        validateMessage.value = errors ? errors[0].message || \"\".concat(props.prop, \" is required\") : \"\";\n        callback(validateMessage.value, errors ? fields : {});\n        (_a = elForm.emit) == null ? void 0 : _a.call(elForm, \"validate\", props.prop, !errors, validateMessage.value || null);\n      });\n    };\n\n    var clearValidate = function clearValidate() {\n      validateState.value = \"\";\n      validateMessage.value = \"\";\n    };\n\n    var resetField = function resetField() {\n      var model = elForm.model;\n      var value = fieldValue.value;\n      var path = props.prop;\n\n      if (path.indexOf(\":\") !== -1) {\n        path = path.replace(/:/, \".\");\n      }\n\n      var prop = getPropByPath(model, path, true);\n\n      if (Array.isArray(value)) {\n        prop.o[prop.k] = [].concat(initialValue);\n      } else {\n        prop.o[prop.k] = initialValue;\n      }\n\n      nextTick(function () {\n        clearValidate();\n      });\n    };\n\n    var getRules = function getRules() {\n      var formRules = elForm.rules;\n      var selfRules = props.rules;\n      var requiredRule = props.required !== void 0 ? {\n        required: !!props.required\n      } : [];\n      var prop = getPropByPath(formRules, props.prop || \"\", false);\n      var normalizedRule = formRules ? prop.o[props.prop || \"\"] || prop.v : [];\n      return [].concat(selfRules || normalizedRule || []).concat(requiredRule);\n    };\n\n    var getFilteredRule = function getFilteredRule(trigger) {\n      var rules = getRules();\n      return rules.filter(function (rule) {\n        if (!rule.trigger || trigger === \"\") return true;\n\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.indexOf(trigger) > -1;\n        } else {\n          return rule.trigger === trigger;\n        }\n      }).map(function (rule) {\n        return _objectSpread({}, rule);\n      });\n    };\n\n    var evaluateValidationEnabled = function evaluateValidationEnabled() {\n      var _a;\n\n      isValidationEnabled.value = !!((_a = getRules()) == null ? void 0 : _a.length);\n    };\n\n    var updateComputedLabelWidth = function updateComputedLabelWidth(width) {\n      computedLabelWidth.value = width ? \"\".concat(width, \"px\") : \"\";\n    };\n\n    var elFormItem = reactive(_objectSpread(_objectSpread({}, toRefs(props)), {}, {\n      size: sizeClass,\n      validateState: validateState,\n      $el: formItemRef,\n      evaluateValidationEnabled: evaluateValidationEnabled,\n      resetField: resetField,\n      clearValidate: clearValidate,\n      validate: validate,\n      updateComputedLabelWidth: updateComputedLabelWidth\n    }));\n    onMounted(function () {\n      if (props.prop) {\n        elForm == null ? void 0 : elForm.addField(elFormItem);\n        var value = fieldValue.value;\n        initialValue = Array.isArray(value) ? _toConsumableArray(value) : value;\n        evaluateValidationEnabled();\n      }\n    });\n    onBeforeUnmount(function () {\n      elForm == null ? void 0 : elForm.removeField(elFormItem);\n    });\n    provide(elFormItemKey, elFormItem);\n    var formItemClass = computed(function () {\n      return [{\n        \"el-form-item--feedback\": elForm.statusIcon,\n        \"is-error\": validateState.value === \"error\",\n        \"is-validating\": validateState.value === \"validating\",\n        \"is-success\": validateState.value === \"success\",\n        \"is-required\": isRequired.value || props.required,\n        \"is-no-asterisk\": elForm.hideRequiredAsterisk\n      }, sizeClass.value ? \"el-form-item--\".concat(sizeClass.value) : \"\"];\n    });\n    var shouldShowError = computed(function () {\n      return validateState.value === \"error\" && props.showMessage && elForm.showMessage;\n    });\n    var currentLabel = computed(function () {\n      return (props.label || \"\") + (elForm.labelSuffix || \"\");\n    });\n    return {\n      formItemRef: formItemRef,\n      formItemClass: formItemClass,\n      shouldShowError: shouldShowError,\n      elForm: elForm,\n      labelStyle: labelStyle,\n      contentStyle: contentStyle,\n      validateMessage: validateMessage,\n      labelFor: labelFor,\n      resetField: resetField,\n      clearValidate: clearValidate,\n      currentLabel: currentLabel\n    };\n  }\n});\n\nvar _hoisted_1 = [\"for\"];\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_LabelWrap = resolveComponent(\"LabelWrap\");\n\n  return openBlock(), createElementBlock(\"div\", {\n    ref: \"formItemRef\",\n    class: normalizeClass([\"el-form-item\", _ctx.formItemClass])\n  }, [createVNode(_component_LabelWrap, {\n    \"is-auto-width\": _ctx.labelStyle.width === \"auto\",\n    \"update-all\": _ctx.elForm.labelWidth === \"auto\"\n  }, {\n    default: withCtx(function () {\n      return [_ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock(\"label\", {\n        key: 0,\n        for: _ctx.labelFor,\n        class: \"el-form-item__label\",\n        style: normalizeStyle(_ctx.labelStyle)\n      }, [renderSlot(_ctx.$slots, \"label\", {\n        label: _ctx.currentLabel\n      }, function () {\n        return [createTextVNode(toDisplayString(_ctx.currentLabel), 1)];\n      })], 12, _hoisted_1)) : createCommentVNode(\"v-if\", true)];\n    }),\n    _: 3\n  }, 8, [\"is-auto-width\", \"update-all\"]), createElementVNode(\"div\", {\n    class: \"el-form-item__content\",\n    style: normalizeStyle(_ctx.contentStyle)\n  }, [renderSlot(_ctx.$slots, \"default\"), createVNode(Transition, {\n    name: \"el-zoom-in-top\"\n  }, {\n    default: withCtx(function () {\n      return [_ctx.shouldShowError ? renderSlot(_ctx.$slots, \"error\", {\n        key: 0,\n        error: _ctx.validateMessage\n      }, function () {\n        return [createElementVNode(\"div\", {\n          class: normalizeClass([\"el-form-item__error\", {\n            \"el-form-item__error--inline\": typeof _ctx.inlineMessage === \"boolean\" ? _ctx.inlineMessage : _ctx.elForm.inlineMessage || false\n          }])\n        }, toDisplayString(_ctx.validateMessage), 3)];\n      }) : createCommentVNode(\"v-if\", true)];\n    }),\n    _: 3\n  })], 4)], 2);\n}\n\nvar FormItem = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { FormItem as default };","map":{"version":3,"mappings":"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","names":["_sfc_main","defineComponent","name","componentName","components","LabelWrap","props","label","String","labelWidth","type","Number","default","prop","required","Boolean","rules","Object","Array","error","validateStatus","for","inlineMessage","showMessage","size","validator","isValidComponentSize","setup","slots","elForm","inject","elFormKey","validateState","ref","validateMessage","isValidationEnabled","computedLabelWidth","formItemRef","vm","getCurrentInstance","isNested","computed","parent","initialValue","watch","val","value","immediate","labelFor","labelStyle","ret","labelPosition","addUnit","width","contentStyle","inline","marginLeft","fieldValue","model","path","indexOf","replace","getPropByPath","v","isRequired","getRules","length","every","rule","sizeClass","useSize","formItem","validate","trigger","callback","NOOP","getFilteredRule","descriptor","forEach","AsyncValidator","firstFields","errors","fields","message","resetField","o","nextTick","clearValidate","formRules","selfRules","requiredRule","map","evaluateValidationEnabled","_a","toRefs","$el","updateComputedLabelWidth","onMounted","elFormItem","onBeforeUnmount","provide","formItemClass","shouldShowError","currentLabel","$setup","class","createVNode","key","style","renderSlot","createElementVNode"],"sources":["../../../../../../packages/components/form/src/form-item.vue"],"sourcesContent":["<template>\n  <div ref=\"formItemRef\" class=\"el-form-item\" :class=\"formItemClass\">\n    <LabelWrap\n      :is-auto-width=\"labelStyle.width === 'auto'\"\n      :update-all=\"elForm.labelWidth === 'auto'\"\n    >\n      <label\n        v-if=\"label || $slots.label\"\n        :for=\"labelFor\"\n        class=\"el-form-item__label\"\n        :style=\"labelStyle\"\n      >\n        <slot name=\"label\" :label=\"currentLabel\">\n          {{ currentLabel }}\n        </slot>\n      </label>\n    </LabelWrap>\n    <div class=\"el-form-item__content\" :style=\"contentStyle\">\n      <slot></slot>\n      <transition name=\"el-zoom-in-top\">\n        <slot v-if=\"shouldShowError\" name=\"error\" :error=\"validateMessage\">\n          <div\n            class=\"el-form-item__error\"\n            :class=\"{\n              'el-form-item__error--inline':\n                typeof inlineMessage === 'boolean'\n                  ? inlineMessage\n                  : elForm.inlineMessage || false,\n            }\"\n          >\n            {{ validateMessage }}\n          </div>\n        </slot>\n      </transition>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  inject,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  toRefs,\n  watch,\n  nextTick,\n} from 'vue'\nimport { NOOP } from '@vue/shared'\nimport AsyncValidator from 'async-validator'\nimport {\n  addUnit,\n  isValidComponentSize,\n  getPropByPath,\n} from '@element-plus/utils'\nimport { elFormItemKey, elFormKey } from '@element-plus/tokens'\nimport { useSize } from '@element-plus/hooks'\nimport LabelWrap from './label-wrap'\n\nimport type { PropType, CSSProperties } from 'vue'\nimport type { ComponentSize } from '@element-plus/constants'\nimport type { ElFormContext, ValidateFieldCallback } from '@element-plus/tokens'\nimport type { FormItemRule } from './form.type'\n\nexport default defineComponent({\n  name: 'ElFormItem',\n  componentName: 'ElFormItem',\n  components: {\n    LabelWrap,\n  },\n  props: {\n    label: String,\n    labelWidth: {\n      type: [String, Number],\n      default: '',\n    },\n    prop: String,\n    required: {\n      type: Boolean,\n      default: undefined,\n    },\n    rules: [Object, Array] as PropType<FormItemRule | FormItemRule[]>,\n    error: String,\n    validateStatus: String,\n    for: String,\n    inlineMessage: {\n      type: [String, Boolean],\n      default: '',\n    },\n    showMessage: {\n      type: Boolean,\n      default: true,\n    },\n    size: {\n      type: String as PropType<ComponentSize>,\n      validator: isValidComponentSize,\n    },\n  },\n  setup(props, { slots }) {\n    const elForm = inject(elFormKey, {} as ElFormContext)\n    const validateState = ref('')\n    const validateMessage = ref('')\n    const isValidationEnabled = ref(false)\n\n    const computedLabelWidth = ref('')\n\n    const formItemRef = ref<HTMLDivElement>()\n\n    const vm = getCurrentInstance()\n    const isNested = computed(() => {\n      let parent = vm.parent\n      while (parent && parent.type.name !== 'ElForm') {\n        if (parent.type.name === 'ElFormItem') {\n          return true\n        }\n        parent = parent.parent\n      }\n      return false\n    })\n\n    let initialValue = undefined\n\n    watch(\n      () => props.error,\n      (val) => {\n        validateMessage.value = val\n        validateState.value = val ? 'error' : ''\n      },\n      {\n        immediate: true,\n      }\n    )\n    watch(\n      () => props.validateStatus,\n      (val) => {\n        validateState.value = val\n      }\n    )\n\n    const labelFor = computed(() => props.for || props.prop)\n    const labelStyle = computed(() => {\n      const ret: CSSProperties = {}\n      if (elForm.labelPosition === 'top') return ret\n      const labelWidth = addUnit(props.labelWidth || elForm.labelWidth)\n      if (labelWidth) {\n        ret.width = labelWidth\n      }\n      return ret\n    })\n    const contentStyle = computed(() => {\n      const ret: CSSProperties = {}\n      if (elForm.labelPosition === 'top' || elForm.inline) {\n        return ret\n      }\n      if (!props.label && !props.labelWidth && isNested.value) {\n        return ret\n      }\n      const labelWidth = addUnit(props.labelWidth || elForm.labelWidth)\n      if (!props.label && !slots.label) {\n        ret.marginLeft = labelWidth\n      }\n      return ret\n    })\n    const fieldValue = computed(() => {\n      const model = elForm.model\n      if (!model || !props.prop) {\n        return\n      }\n\n      let path = props.prop\n      if (path.indexOf(':') !== -1) {\n        path = path.replace(/:/, '.')\n      }\n\n      return getPropByPath(model, path, true).v\n    })\n    const isRequired = computed(() => {\n      const rules = getRules()\n      let required = false\n\n      if (rules && rules.length) {\n        rules.every((rule) => {\n          if (rule.required) {\n            required = true\n            return false\n          }\n          return true\n        })\n      }\n      return required\n    })\n    const sizeClass = useSize(undefined, { formItem: false })\n\n    const validate = (\n      trigger: string,\n      callback: ValidateFieldCallback = NOOP\n    ) => {\n      if (!isValidationEnabled.value) {\n        callback()\n        return\n      }\n      const rules = getFilteredRule(trigger)\n      if ((!rules || rules.length === 0) && props.required === undefined) {\n        callback()\n        return\n      }\n      validateState.value = 'validating'\n      const descriptor = {}\n      if (rules && rules.length > 0) {\n        rules.forEach((rule) => {\n          delete rule.trigger\n        })\n      }\n      descriptor[props.prop] = rules\n      const validator = new AsyncValidator(descriptor)\n      const model = {}\n      model[props.prop] = fieldValue.value\n      validator.validate(model, { firstFields: true }, (errors, fields) => {\n        validateState.value = !errors ? 'success' : 'error'\n        validateMessage.value = errors\n          ? errors[0].message || `${props.prop} is required`\n          : ''\n        // fix: #3860 after version 3.5.2, async-validator also return fields if validation fails\n        callback(validateMessage.value, errors ? fields : {})\n        elForm.emit?.(\n          'validate',\n          props.prop,\n          !errors,\n          validateMessage.value || null\n        )\n      })\n    }\n\n    const clearValidate = () => {\n      validateState.value = ''\n      validateMessage.value = ''\n    }\n    const resetField = () => {\n      const model = elForm.model\n      const value = fieldValue.value\n      let path = props.prop\n      if (path.indexOf(':') !== -1) {\n        path = path.replace(/:/, '.')\n      }\n      const prop = getPropByPath(model, path, true)\n      if (Array.isArray(value)) {\n        prop.o[prop.k] = [].concat(initialValue)\n      } else {\n        prop.o[prop.k] = initialValue\n      }\n      nextTick(() => {\n        clearValidate()\n      })\n    }\n\n    const getRules = () => {\n      const formRules = elForm.rules\n      const selfRules = props.rules\n      const requiredRule =\n        props.required !== undefined ? { required: !!props.required } : []\n\n      const prop = getPropByPath(formRules, props.prop || '', false)\n      const normalizedRule = formRules ? prop.o[props.prop || ''] || prop.v : []\n\n      return [].concat(selfRules || normalizedRule || []).concat(requiredRule)\n    }\n    const getFilteredRule = (trigger) => {\n      const rules = getRules()\n\n      return rules\n        .filter((rule) => {\n          if (!rule.trigger || trigger === '') return true\n          if (Array.isArray(rule.trigger)) {\n            return rule.trigger.indexOf(trigger) > -1\n          } else {\n            return rule.trigger === trigger\n          }\n        })\n        .map((rule) => ({ ...rule }))\n    }\n\n    const evaluateValidationEnabled = () => {\n      isValidationEnabled.value = !!getRules()?.length\n    }\n\n    const updateComputedLabelWidth = (width: string | number) => {\n      computedLabelWidth.value = width ? `${width}px` : ''\n    }\n\n    const elFormItem = reactive({\n      ...toRefs(props),\n      size: sizeClass,\n      validateState,\n      $el: formItemRef,\n      evaluateValidationEnabled,\n      resetField,\n      clearValidate,\n      validate,\n      updateComputedLabelWidth,\n    })\n\n    onMounted(() => {\n      if (props.prop) {\n        elForm?.addField(elFormItem)\n\n        const value = fieldValue.value\n        initialValue = Array.isArray(value) ? [...value] : value\n\n        evaluateValidationEnabled()\n      }\n    })\n    onBeforeUnmount(() => {\n      elForm?.removeField(elFormItem)\n    })\n\n    provide(elFormItemKey, elFormItem)\n\n    const formItemClass = computed(() => [\n      {\n        'el-form-item--feedback': elForm.statusIcon,\n        'is-error': validateState.value === 'error',\n        'is-validating': validateState.value === 'validating',\n        'is-success': validateState.value === 'success',\n        'is-required': isRequired.value || props.required,\n        'is-no-asterisk': elForm.hideRequiredAsterisk,\n      },\n      sizeClass.value ? `el-form-item--${sizeClass.value}` : '',\n    ])\n\n    const shouldShowError = computed(() => {\n      return (\n        validateState.value === 'error' &&\n        props.showMessage &&\n        elForm.showMessage\n      )\n    })\n\n    const currentLabel = computed(\n      () => (props.label || '') + (elForm.labelSuffix || '')\n    )\n\n    return {\n      formItemRef,\n      formItemClass,\n      shouldShowError,\n      elForm,\n      labelStyle,\n      contentStyle,\n      validateMessage,\n      labelFor,\n      resetField,\n      clearValidate,\n      currentLabel,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}