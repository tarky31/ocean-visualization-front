{"ast":null,"code":"import _defineProperty from \"D:/MyFile/WebCode/ocean-vis/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"D:/MyFile/WebCode/ocean-vis/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport { defineComponent, shallowRef, ref, computed, watch, onMounted, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createElementVNode, renderSlot } from 'vue';\nimport { useEventListener, useResizeObserver } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { affixProps, affixEmits } from './affix.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { getScrollContainer } from '../../../utils/dom/scroll.mjs';\nvar __default__ = {\n  name: \"ElAffix\"\n};\n\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: affixProps,\n  emits: affixEmits,\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose,\n        emit = _ref.emit;\n    var props = __props;\n    var ns = useNamespace(\"affix\");\n    var target = shallowRef();\n    var root = shallowRef();\n    var scrollContainer = shallowRef();\n    var fixed = ref(false);\n    var height = ref(0);\n    var width = ref(0);\n    var scrollTop = ref(0);\n    var clientHeight = ref(0);\n    var transform = ref(0);\n    var rootStyle = computed(function () {\n      return {\n        height: fixed.value ? \"\".concat(height.value, \"px\") : \"\",\n        width: fixed.value ? \"\".concat(width.value, \"px\") : \"\"\n      };\n    });\n    var affixStyle = computed(function () {\n      if (!fixed.value) return;\n      var offset = props.offset ? \"\".concat(props.offset, \"px\") : 0;\n\n      var _transform = transform.value ? \"translateY(\".concat(transform.value, \"px)\") : \"\";\n\n      return {\n        height: \"\".concat(height.value, \"px\"),\n        width: \"\".concat(width.value, \"px\"),\n        top: props.position === \"top\" ? offset : \"\",\n        bottom: props.position === \"bottom\" ? offset : \"\",\n        transform: _transform,\n        zIndex: props.zIndex\n      };\n    });\n\n    var update = function update() {\n      if (!root.value || !target.value || !scrollContainer.value) return;\n      var rootRect = root.value.getBoundingClientRect();\n      var targetRect = target.value.getBoundingClientRect();\n      height.value = rootRect.height;\n      width.value = rootRect.width;\n      scrollTop.value = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;\n      clientHeight.value = document.documentElement.clientHeight;\n\n      if (props.position === \"top\") {\n        if (props.target) {\n          var difference = targetRect.bottom - props.offset - height.value;\n          fixed.value = props.offset > rootRect.top && targetRect.bottom > 0;\n          transform.value = difference < 0 ? difference : 0;\n        } else {\n          fixed.value = props.offset > rootRect.top;\n        }\n      } else {\n        if (props.target) {\n          var _difference = clientHeight.value - targetRect.top - props.offset - height.value;\n\n          fixed.value = clientHeight.value - props.offset < rootRect.bottom && clientHeight.value > targetRect.top;\n          transform.value = _difference < 0 ? -_difference : 0;\n        } else {\n          fixed.value = clientHeight.value - props.offset < rootRect.bottom;\n        }\n      }\n    };\n\n    var onScroll = function onScroll() {\n      update();\n      emit(\"scroll\", {\n        scrollTop: scrollTop.value,\n        fixed: fixed.value\n      });\n    };\n\n    watch(fixed, function (fixed2) {\n      emit(\"change\", fixed2);\n    });\n    onMounted(function () {\n      var _a;\n\n      if (props.target) {\n        target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;\n\n        if (!target.value) {\n          throw new Error(\"Target is not existed: \".concat(props.target));\n        }\n      } else {\n        target.value = document.documentElement;\n      }\n\n      scrollContainer.value = getScrollContainer(root.value, true);\n    });\n    useEventListener(scrollContainer, \"scroll\", onScroll);\n    useResizeObserver(root, function () {\n      return update();\n    });\n    useResizeObserver(target, function () {\n      return update();\n    });\n    expose({\n      update: update\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"root\",\n        ref: root,\n        class: normalizeClass(unref(ns).b()),\n        style: normalizeStyle(unref(rootStyle))\n      }, [createElementVNode(\"div\", {\n        class: normalizeClass(_defineProperty({}, unref(ns).m(\"fixed\"), fixed.value)),\n        style: normalizeStyle(unref(affixStyle))\n      }, [renderSlot(_ctx.$slots, \"default\")], 6)], 6);\n    };\n  }\n}));\n\nexport { _sfc_main as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;AAuBA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;KAAA;AAOA;;;;;;;;;;;;;;KAAA;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;KAAA;;AAmCA;;;;;;KAAA;;AASAA;;KAAA;AAIAC;;;;;;;;;;;;;;AAaA,KAbA;AAcAC;AACAC;AAAA;AAAA;AAEAA;AAAA;AAAA","names":["watch","onMounted","useEventListener","useResizeObserver"],"sources":["../../../../../../packages/components/affix/src/affix.vue"],"sourcesContent":["<template>\n  <div ref=\"root\" :class=\"ns.b()\" :style=\"rootStyle\">\n    <div :class=\"{ [ns.m('fixed')]: fixed }\" :style=\"affixStyle\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n<script lang=\"ts\" setup>\nimport { computed, onMounted, ref, shallowRef, watch } from 'vue'\nimport { useEventListener, useResizeObserver } from '@vueuse/core'\nimport { getScrollContainer } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { affixEmits, affixProps } from './affix'\n\nimport type { CSSProperties } from 'vue'\n\ndefineOptions({\n  name: 'ElAffix',\n})\n\nconst props = defineProps(affixProps)\nconst emit = defineEmits(affixEmits)\n\nconst ns = useNamespace('affix')\n\nconst target = shallowRef<HTMLElement>()\nconst root = shallowRef<HTMLDivElement>()\nconst scrollContainer = shallowRef<HTMLElement | Window>()\n\nconst fixed = ref(false)\nconst height = ref(0) // height of root\nconst width = ref(0) // width of root\nconst scrollTop = ref(0) // scrollTop of documentElement\nconst clientHeight = ref(0) // clientHeight of documentElement\nconst transform = ref(0)\n\nconst rootStyle = computed<CSSProperties>(() => {\n  return {\n    height: fixed.value ? `${height.value}px` : '',\n    width: fixed.value ? `${width.value}px` : '',\n  }\n})\n\nconst affixStyle = computed<CSSProperties | undefined>(() => {\n  if (!fixed.value) return\n\n  const offset = props.offset ? `${props.offset}px` : 0\n  const _transform = transform.value ? `translateY(${transform.value}px)` : ''\n\n  return {\n    height: `${height.value}px`,\n    width: `${width.value}px`,\n    top: props.position === 'top' ? offset : '',\n    bottom: props.position === 'bottom' ? offset : '',\n    transform: _transform,\n    zIndex: props.zIndex,\n  }\n})\n\nconst update = () => {\n  if (!root.value || !target.value || !scrollContainer.value) return\n\n  const rootRect = root.value.getBoundingClientRect()\n  const targetRect = target.value.getBoundingClientRect()\n  height.value = rootRect.height\n  width.value = rootRect.width\n  scrollTop.value =\n    scrollContainer.value instanceof Window\n      ? document.documentElement.scrollTop\n      : scrollContainer.value.scrollTop || 0\n  clientHeight.value = document.documentElement.clientHeight\n\n  if (props.position === 'top') {\n    if (props.target) {\n      const difference = targetRect.bottom - props.offset - height.value\n      fixed.value = props.offset > rootRect.top && targetRect.bottom > 0\n      transform.value = difference < 0 ? difference : 0\n    } else {\n      fixed.value = props.offset > rootRect.top\n    }\n  } else {\n    if (props.target) {\n      const difference =\n        clientHeight.value - targetRect.top - props.offset - height.value\n      fixed.value =\n        clientHeight.value - props.offset < rootRect.bottom &&\n        clientHeight.value > targetRect.top\n      transform.value = difference < 0 ? -difference : 0\n    } else {\n      fixed.value = clientHeight.value - props.offset < rootRect.bottom\n    }\n  }\n}\n\nconst onScroll = () => {\n  update()\n\n  emit('scroll', {\n    scrollTop: scrollTop.value,\n    fixed: fixed.value,\n  })\n}\n\nwatch(fixed, (fixed) => {\n  emit('change', fixed)\n})\n\nonMounted(() => {\n  if (props.target) {\n    target.value =\n      document.querySelector<HTMLElement>(props.target) ?? undefined\n    if (!target.value) {\n      throw new Error(`Target is not existed: ${props.target}`)\n    }\n  } else {\n    target.value = document.documentElement\n  }\n  scrollContainer.value = getScrollContainer(root.value!, true)\n})\n\nuseEventListener(scrollContainer, 'scroll', onScroll)\nuseResizeObserver(root, () => update())\nuseResizeObserver(target, () => update())\n\ndefineExpose({\n  /** @description update affix status */\n  update,\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}